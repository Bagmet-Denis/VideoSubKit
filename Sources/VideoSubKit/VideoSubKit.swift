// The Swift Programming Language
// https://docs.swift.org/swift-book

import UIKit

let textSize: CGFloat = 36
let activeTextColor: UIColor = UIColor.orange
let inactiveTextColor: UIColor = UIColor.gray

@MainActor let activeBackgroundType: BackgroundType = .rounded
@MainActor let inactiveBackgroundType: BackgroundType = .none

let activeBackgroundColors: [UIColor] = [UIColor.orange.withAlphaComponent(0.5)]
let inactiveBackgroundColors: [UIColor] = [UIColor.orange]

@MainActor public let testSubtitles: [SubtitleSegment] = [
    SubtitleSegment(id: UUID(), text: "–≠—Ç–æ", textSize: 36, startTime: 0.0, endTime: 1.0, textEffect: TextEffect(fontName: nil, textColor: UIColor.black, textGradientColors: nil, textPattern: nil, strokeStyles: [], globalStroke: nil, textShadows: [], animations: [], backgroundType: .rectangle, backgroundColors: [UIColor.green], backgroundPattern: nil)),
    
    SubtitleSegment(id: UUID(), text: "–ø—Ä–æ—Å—Ç–æ–π", textSize: 36, startTime: 1.0, endTime: 2.0, textEffect: TextEffect(fontName: nil, textColor: UIColor.black, textGradientColors: nil, textPattern: nil, strokeStyles: [], globalStroke: nil, textShadows: [], animations: [], backgroundType: .rectangle, backgroundColors: [UIColor.green], backgroundPattern: nil)),
    
    SubtitleSegment(id: UUID(), text: "–ø—Ä–∏–º–µ—Ä", textSize: 36, startTime: 2.0, endTime: 3.0, textEffect: TextEffect(fontName: nil, textColor: UIColor.black, textGradientColors: nil, textPattern: nil, strokeStyles: [], globalStroke: nil, textShadows: [], animations: [], backgroundType: .rectangle, backgroundColors: [UIColor.green], backgroundPattern: nil)),
    
    SubtitleSegment(id: UUID(), text: "—Ç–µ–∫—Å—Ç–∞", textSize: 36, startTime: 3.0, endTime: 4.0, textEffect: TextEffect(fontName: nil, textColor: UIColor.black, textGradientColors: nil, textPattern: nil, strokeStyles: [], globalStroke: nil, textShadows: [], animations: [], backgroundType: .rectangle, backgroundColors: [UIColor.green], backgroundPattern: nil)),
    
    SubtitleSegment(id: UUID(), text: "—Å", textSize: 36, startTime: 4.0, endTime: 4.5, textEffect: TextEffect(fontName: nil, textColor: UIColor.black, textGradientColors: nil, textPattern: nil, strokeStyles: [], globalStroke: nil, textShadows: [], animations: [], backgroundType: Optional.none, backgroundColors: [UIColor.green], backgroundPattern: nil)),
    
    SubtitleSegment(id: UUID(), text: "–∞–Ω–∏–º–∞—Ü–∏–µ–π", textSize: 36, startTime: 4.5, endTime: 5.5, textEffect: TextEffect(fontName: nil, textColor: UIColor.black, textGradientColors: nil, textPattern: nil, strokeStyles: [], globalStroke: nil, textShadows: [], animations: [], backgroundType: .rectangle, backgroundColors: [UIColor.green], backgroundPattern: nil)),
]

@MainActor func applyEffect(subtitles: [SubtitleSegment]) -> [SubtitleSegment]{
    var appliedSubtitles: [SubtitleSegment] = []
    
    let activeTextEffect = TextEffect(textColor: activeTextColor, strokeStyles: [], textShadows: [], animations: [], backgroundType: activeBackgroundType, backgroundColors: activeBackgroundColors)
    let inactiveTextEffect = TextEffect(textColor: inactiveTextColor, strokeStyles: [], textShadows: [], animations: [], backgroundType: inactiveBackgroundType, backgroundColors: inactiveBackgroundColors)
    
    for subtitle in subtitles {
        appliedSubtitles.append(SubtitleSegment(text: subtitle.text, textSize: subtitle.textSize, startTime: subtitle.startTime, endTime: subtitle.endTime, textEffect: activeTextEffect, inactiveTextEffect: inactiveTextEffect))
    }
    
    return appliedSubtitles
}

func calculateTextSize(text: String, font: UIFont, maxWidth: CGFloat) -> CGSize {
    let textStorage = NSTextStorage(string: text, attributes: [.font: font])
    let layoutManager = NSLayoutManager()
    let textContainer = NSTextContainer(size: CGSize(width: maxWidth, height: .greatestFiniteMagnitude))
    
    textContainer.lineBreakMode = .byWordWrapping
    textContainer.lineFragmentPadding = 0.0
    layoutManager.addTextContainer(textContainer)
    textStorage.addLayoutManager(layoutManager)
    
    layoutManager.glyphRange(for: textContainer) // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á—ë—Ç
    
    let rect = layoutManager.usedRect(for: textContainer)
    return CGSize(width: ceil(rect.width), height: ceil(rect.height))
}

func createMainTextLayer(subtitle: SubtitleSegment, isActive: Bool, textWidth: CGFloat, textHeight: CGFloat) -> CATextLayer {
    let textLayer = CATextLayer()
    textLayer.contentsScale = 1
    textLayer.alignmentMode = .center
    textLayer.frame = CGRect(x: 0, y: 0, width: textWidth, height: textHeight)
    
    // ‚ö°Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç, –µ—Å–ª–∏ –æ–Ω –∑–∞–¥–∞–Ω
    let font: UIFont
    if let fontName = subtitle.textEffect.fontName, let customFont = UIFont(name: fontName, size: subtitle.textSize) {
        font = customFont
    } else {
        font = UIFont.boldSystemFont(ofSize: subtitle.textSize) // –§–æ–ª–ª–±—ç–∫ –Ω–∞ —Å–∏—Å—Ç–µ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç
    }
    
    let attributedText = NSAttributedString(
        string: subtitle.text,
        attributes: [
            .foregroundColor: isActive ? subtitle.textEffect.textColor : subtitle.inactiveTextEffect?.textColor ?? subtitle.textEffect.textColor,
            .font: font
        ]
    )
    
    textLayer.string = attributedText
    
    let correctTextHeight = textHeight + font.ascender
    
        textLayer.frame = CGRect(
            x: 0,
            y: 0,
            width: textWidth,
            height: correctTextHeight
        )
    
    return textLayer
}

func setVisibleSubtitles(_ subtitles: inout [SubtitleSegment]){
    for index in subtitles.indices{
        var subtitle = subtitles[index]
        let duration = 0.5
        
        let fadeIn = CABasicAnimation(keyPath: "opacity")
        fadeIn.fromValue = 0.0
        fadeIn.toValue = 1.0
        fadeIn.beginTime = CACurrentMediaTime() + subtitle.startTime
        fadeIn.duration = duration
        fadeIn.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        fadeIn.fillMode = .forwards
        fadeIn.isRemovedOnCompletion = false

        let fadeOut = CABasicAnimation(keyPath: "opacity")
        fadeOut.fromValue = 1.0
        fadeOut.toValue = 0.0
        fadeOut.beginTime = CACurrentMediaTime() + subtitle.endTime - duration
        fadeOut.duration = duration
        fadeOut.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        fadeOut.fillMode = .forwards
        fadeOut.isRemovedOnCompletion = false
        
        subtitles[index].textEffect.animations.append(contentsOf: [fadeIn, fadeOut])
    }
}

func setVisibleLayer(_ layer: CALayer, beginTime: TimeInterval, endTime: TimeInterval, duration: TimeInterval) -> CALayer{
    let fadeIn = CABasicAnimation(keyPath: "opacity")
    fadeIn.fromValue = 0.0
    fadeIn.toValue = 1.0
    fadeIn.beginTime = CACurrentMediaTime() + beginTime
    fadeIn.duration = duration
    fadeIn.timingFunction = CAMediaTimingFunction(name: .linear)
    fadeIn.fillMode = .forwards
    fadeIn.isRemovedOnCompletion = false

    let fadeOut = CABasicAnimation(keyPath: "opacity")
    fadeOut.fromValue = 1.0
    fadeOut.toValue = 0.0
    fadeOut.beginTime = CACurrentMediaTime() + endTime - duration
    fadeOut.duration = duration
    fadeOut.timingFunction = CAMediaTimingFunction(name: .linear)
    fadeOut.fillMode = .forwards
    fadeOut.isRemovedOnCompletion = false
    
    layer.add(fadeIn, forKey: "fadeIn")
    layer.add(fadeOut, forKey: "fadeOut")
    
    return layer
}

func createBackgroundLayer(subtitle: SubtitleSegment, isActive: Bool, textWidth: CGFloat, textHeight: CGFloat, textPosition: CGPoint) -> CALayer {
    let backgroundLayer = CALayer()
    
    let adjustedHeight = textHeight + subtitle.textSize * 0.2
    
    backgroundLayer.frame = CGRect(
        x: textPosition.x,
        y: textPosition.y - subtitle.textSize * 0.1,
        width: textWidth,
        height: textHeight
    )
    
    if isActive{
        // üé® 1Ô∏è‚É£ –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω –ü–ê–¢–¢–ï–†–ù (–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)
    //    if let patternImage = subtitle.textEffect.backgroundPattern {
    //        let patternLayer = CALayer()
    //        patternLayer.contents = patternImage.cgImage
    //        patternLayer.frame = backgroundLayer.bounds
    //        backgroundLayer.addSublayer(patternLayer)
    //        return backgroundLayer
    //    }
    //
    //    // üé® 2Ô∏è‚É£ –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω –ì–†–ê–î–ò–ï–ù–¢
    //    if let backgroundColors = subtitle.textEffect.backgroundColors, backgroundColors.count > 1 {
    //        let gradientLayer = CAGradientLayer()
    //        gradientLayer.colors = backgroundColors.map { $0.cgColor }
    //        gradientLayer.startPoint = CGPoint(x: 0, y: 0)
    //        gradientLayer.endPoint = CGPoint(x: 1, y: 1)
    //        gradientLayer.frame = backgroundLayer.bounds
    //
    //        // ‚úÖ –î–µ–ª–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –ø—Ä–∏–º–µ–Ω–∏–º—ã–º —Ç–æ–ª—å–∫–æ –∫ —Ç–µ–∫—Å—Ç—É
    //        let maskLayer = CATextLayer()
    //        maskLayer.string = subtitle.text
    //        maskLayer.fontSize = subtitle.textSize
    //        maskLayer.alignmentMode = .center
    //        maskLayer.contentsScale = 1
    //        maskLayer.frame = backgroundLayer.bounds
    //
    //        gradientLayer.mask = maskLayer
    //        backgroundLayer.addSublayer(gradientLayer)
    //
    //        return backgroundLayer
    //    }

        // üé® 3Ô∏è‚É£ –ï—Å–ª–∏ –æ–¥–∏–Ω —Ü–≤–µ—Ç
        if let backgroundColor = subtitle.textEffect.backgroundColors?.first {
            backgroundLayer.backgroundColor = backgroundColor.cgColor
        }
        
        if subtitle.textEffect.backgroundType == .rounded{
            backgroundLayer.cornerRadius = subtitle.textEffect.backgroundRoundedCorners ?? 0
            backgroundLayer.masksToBounds = true
        }

        return backgroundLayer
    }else{
        // üé® 3Ô∏è‚É£ –ï—Å–ª–∏ –æ–¥–∏–Ω —Ü–≤–µ—Ç
        if let backgroundColor = subtitle.inactiveTextEffect?.backgroundColors?.first {
            backgroundLayer.backgroundColor = backgroundColor.cgColor
        }
        
        if subtitle.inactiveTextEffect?.backgroundType == .rounded{
            backgroundLayer.cornerRadius = subtitle.inactiveTextEffect?.backgroundRoundedCorners ?? 0
            backgroundLayer.masksToBounds = true
        }
        
        return backgroundLayer
    }
}

func createTextLayer(subtitle: SubtitleSegment, isActive: Bool, rectSize: CGSize) -> CALayer {
    let parentLayer = CALayer()
    
    let textWidth: CGFloat = rectSize.width
    let textHeight: CGFloat = subtitle.textSize
    let textPosition = CGPoint(x: 0, y: 0)
    
    // üé® –°–æ–∑–¥–∞—ë–º –§–û–ù
    let backgroundLayer = createBackgroundLayer(subtitle: subtitle, isActive: isActive, textWidth: textWidth, textHeight: textHeight, textPosition: textPosition)
    
    // üåü –°–æ–∑–¥–∞—ë–º –¢–ï–ù–ò
    //    let shadows = subtitle.textEffect?.textShadows ?? []
    //    let shadowLayers: [CALayer] = shadows.map { shadow in
    //        createShadowLayer(subtitle: subtitle, videoSize: videoSize, textShadow: shadow)
    //    }
    
    // üéØ –û—Å–Ω–æ–≤–Ω–æ–π –¢–ï–ö–°–¢ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω
    //    let textLayer: CALayer
    //    if let patternImage = subtitle.textEffect?.textPattern {
    ////        textLayer = createPatternTextLayer(subtitle: subtitle, textWidth: textWidth, textHeight: textHeight, patternImage: patternImage)
    //    } else if let gradientColors = subtitle.textEffect?.textGradientColors {
    ////        textLayer = createGradientTextLayer(subtitle: subtitle, textWidth: textWidth, textHeight: textHeight, gradientColors: gradientColors)
    //    } else {
    //        textLayer = createMainTextLayer(subtitle: subtitle, textWidth: textWidth, textHeight: textHeight)
    //    }
    
    let textLayer = createMainTextLayer(subtitle: subtitle, isActive: isActive, textWidth: textWidth, textHeight: textHeight)
    // üé® –°–æ–∑–¥–∞—ë–º –û–ë–´–ß–ù–´–ï –û–ë–í–û–î–ö–ò
    //    let strokeLayers: [CATextLayer] = (subtitle.textEffect?.strokeStyles ?? []).reversed().map { stroke in
    //        createStrokeLayer(strokeColor: stroke.color, strokeWidth: stroke.width, subtitle: subtitle, videoSize: videoSize)
    //    }
    
    // üîπ –î–æ–±–∞–≤–ª—è–µ–º –≤—Å—ë –≤ `parentLayer`
    //    shadowLayers.forEach { parentLayer.addSublayer($0) } // –¢–µ–Ω–∏
    //    strokeLayers.forEach { backgroundLayer.addSublayer($0) } // –û–±—ã—á–Ω—ã–µ –æ–±–≤–æ–¥–∫–∏
    backgroundLayer.addSublayer(textLayer) // –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç
    parentLayer.addSublayer(backgroundLayer) // –§–æ–Ω
    
    // üèó –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
//    parentLayer.opacity = 0.0
    
    // ‚ú® –ü—Ä–∏–º–µ–Ω—è–µ–º –∞–Ω–∏–º–∞—Ü–∏–∏
    for animation in subtitle.textEffect.animations {
        parentLayer.add(animation, forKey: nil)
    }
    
    return parentLayer
}

func createMultiStyleTextLayer(phrase: [SubtitleSegment], indexCurrentWord: Int, beginTimeActiveWord: TimeInterval, endTimeActiveWord: TimeInterval, rect: CGSize) -> CALayer {
    let parentLayer = CALayer()
    
    var remainingWidth = rect.width
    let wordSpacing: CGFloat = 5.0
    let lineSpacing: CGFloat = 5.0

    var currentX: CGFloat = 0
    var currentY: CGFloat = 0
    var maxHeightInLine: CGFloat = 0

    var startVisibleLayerTimeInterval: TimeInterval = 0
    var endVisibleLayerTimeInterval: TimeInterval = 0
    
    for (index, word) in phrase.enumerated() {
        // ‚ö°Ô∏è –û–ø—Ä–µ–¥–µ–ª—è–µ–º —à—Ä–∏—Ñ—Ç —Ç–µ–∫—Å—Ç–∞
        let font: UIFont
        if let fontName = word.textEffect.fontName, let customFont = UIFont(name: fontName, size: word.textSize) {
            font = customFont
        } else {
            font = UIFont.boldSystemFont(ofSize: word.textSize)
        }

        // üìè –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞
        let textSize = calculateTextSize(text: word.text, font: font, maxWidth: rect.width)

        // üõë –ï—Å–ª–∏ —Å–ª–æ–≤–æ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è –≤ —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É ‚Äî –ø–µ—Ä–µ–Ω–æ—Å–∏–º –Ω–∞ –Ω–æ–≤—É—é
        if textSize.width > remainingWidth {
            currentX = 0 // –°–±—Ä–∞—Å—ã–≤–∞–µ–º X (–Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞)
            currentY += maxHeightInLine + lineSpacing // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
            remainingWidth = rect.width // –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ—Å—Ç—É–ø–Ω—É—é —à–∏—Ä–∏–Ω—É
            maxHeightInLine = 0 // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É —Å—Ç—Ä–æ–∫–∏
        }

        // üõë –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ ‚Äî –≤—ã—Ö–æ–¥–∏–º
        if currentY + textSize.height > rect.height {
            print("–¢–µ–∫—Å—Ç –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –ø—Ä–µ–∫—Ä–∞—â–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ")
            break
        }

        
        let isActive = word.startTime >= beginTimeActiveWord && word.endTime <= endTimeActiveWord
        let layer = createTextLayer(subtitle: word, isActive: isActive, rectSize: textSize)

        layer.frame = CGRect(
            x: currentX,
            y: currentY,
            width: textSize.width,
            height: textSize.height
        )

        parentLayer.addSublayer(layer)

        // üîπ –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ª–æ–≤–∞
        currentX += textSize.width + wordSpacing
        remainingWidth -= (textSize.width + wordSpacing)

        // üîπ –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –≤ —Å—Ç—Ä–æ–∫–µ
        maxHeightInLine = max(maxHeightInLine, textSize.height)
        
        if isActive && indexCurrentWord == index{
            startVisibleLayerTimeInterval = word.startTime
            endVisibleLayerTimeInterval = word.endTime
        }
    }

    let finishLayer = setVisibleLayer(parentLayer, beginTime: startVisibleLayerTimeInterval, endTime: endVisibleLayerTimeInterval, duration: 0.001)
    finishLayer.backgroundColor = UIColor.red.cgColor
    finishLayer.opacity = 0.0
    return finishLayer
}


func createPhraseLayer(subtitles: [SubtitleSegment], rect: CGSize) -> CALayer{
    let parentLayer = CALayer()
        
    for (index, subtitle) in subtitles.enumerated() {
        let phrase = createMultiStyleTextLayer(phrase: subtitles, indexCurrentWord: index, beginTimeActiveWord: subtitle.startTime, endTimeActiveWord: subtitle.endTime, rect: rect)
        
        parentLayer.addSublayer(phrase)
    }

    return parentLayer
}
